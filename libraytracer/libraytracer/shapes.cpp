#include "shapes.h"

////////////////////////////////////////////////////////////////////////////////////////////////////
/// Shape
////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////
Shape::Shape(Tuple position)
:   position(position),
    transformation(TransformationMatrix::identity())
{}

////////////////////////////////////////////////////////////////////////////////////////////////////
bool operator==(const Shape& a, const Shape& b)
{
    return &a == &b;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
Tuple Shape::getPosition() const
{
    return position;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
TransformationMatrix Shape::getTransform() const
{
    return transformation;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
void Shape::setTransform(TransformationMatrix t)
{
    transformation = t;
}


////////////////////////////////////////////////////////////////////////////////////////////////////
/// Sphere
////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////
Tuple Sphere::normalAt(Tuple worldPoint)
{
    const TransformationMatrix inverseTransform = transformation.inverse();
    const auto objectPoint = inverseTransform * worldPoint;
    const auto objectNormal = objectPoint - Point{};
    auto worldNormal = inverseTransform.transposed() * objectNormal;
    worldNormal.w = 0.0; // hacky way of avoiding having another submatrix operation
    return worldNormal.normalize();
}
